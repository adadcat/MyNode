一、面向对象的三大特性：
1.封装：把属性和行为作为一个整体
	赋予属性和行为不同的权限:
	public(公共权限)：类内可以访问 类外可以访问
	protected(保护权限)：类内可以访问 类外不可以访问
	private（私有权限）：类内可以访问 类外不可以访问
	 
![fengzhuang](https://github.com/adadcat/MyNode/blob/main/Photo-/fengzhuang.png)

2.类的构造函数：
	一种特殊的成员函数，在每次创建类的新对象时执行。
	构造函数的名称和类的名称都是相同的，不会返回任何类型，包括void（）。构造函数可以为某些成员变量设置初始值。
 
![2-1](https://github.com/adadcat/MyNode/blob/main/Photo-/gouzao1.png)

![2-2](https://github.com/adadcat/MyNode/blob/main/Photo-/gouzao2.png)

3.类的析构函数
	类的一种特殊成员函数，在删除所创建的对象中执行。
	析构函数的名称和类的名称完全相同，只是在前面加了一个~作为前缀，不会返回仍和值，也不能带任何参数。
	析构函数有利于在函数关闭前（关闭文件，释放内存）释放资源。
 
 ![3-1](https://github.com/adadcat/MyNode/blob/main/Photo-/xigou1.png)
 
最后的时候执行析构函数，释放内存。
 ![3-2](https://github.com/adadcat/MyNode/blob/main/Photo-/xigou2.png)
 
4.赋值函数
	C++支持自定义类型的对象之间的赋值操作，而赋值功能的实现则主要依靠自定义类中的赋值函数。每一个自定义类中都有且只有一个赋值函数，该赋值函数既可以由编译器隐式地定义在自定义类中，也可以有用户通过对赋值运算符=的重载显式地定义在自定义类中。

5.拷贝构造函数
	在创建新的对象前，使用同一类中之前创建的对象来初始化新创建的对象。常用于：
	1、通过使用另一个同类型的对象来初始化新创建的对象。
	2、复制对象把他作为参数来传递给函数
	3、复制对象，并从函数返回这个对象
	如果类没有定义一个拷贝构造函数，则编译器会自己定义一个。如果这个类带有一个指针变量，并有动态内存分布，则必须定义一个拷贝构造函数。
 
6、移动构造函数和拷贝构造函数的区别
	移动构造函数是一个右值，用&&标出。一般来说，左值可以通过使用std：move强制转换成右值。
值类型包括3个基本类型：lvalue、rvalue。lvalue为左值，左值可看成是一个可以获取地址的量，它可以用来标识一个对象或函数。rvalue则称为右值。
	拷贝构造函数是先将传入的参数进行一次深拷贝，再传入新的对象。就会形成一次拷贝对象的开销。
	移动构造函数的目的就是为了解决这个拷贝开销。它首先将这个参数的内存地址空间接管，并将内部所有的指针置为nullptr（nullptr是nullptr_t类型的右值常量，专用于初始化空类型指针。nullptr_t可称为“指针空值类型”）。然后在原地址上进行新对象的构造，最后调用原对象的析构函数。这样既不会产生额外的拷贝开销，也不会对新对象分配内存空间。


7、深拷贝与浅拷贝的区别
浅拷贝：
只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址。如果原来的指针所指向的资源被释放，那么再释放浅拷贝的内存资源就会出现错误。
浅拷贝所指向的是被复制的内存地址，如果该内存地址的对象发生改变，那么浅拷贝的内容也会发生改变。
深拷贝：
深拷贝不仅拷贝值，还会开辟一个新的空间存储拷贝值。如果被拷贝对象析构掉，不会对拷贝值有影。

8、空类会有6个成员函数：析构函数，缺省的构造函数，拷贝构造函数、析构函数、赋值运算符、一对取址运算符、this指针。
![8-1](https://github.com/adadcat/MyNode/blob/main/Photo-/konglei.png)

9、内存分区：
	（1）程序代码区：存放函数体（类的全局变量、全局函数）的二进制代码。
	（2）全局/静态区（static）：全局变量和静态变量的存储是放在一起的，在编译的时候分配。
	（3）文字常量区：存放常量字符串。
	（4）栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量值等。
	（5）堆区（heap）：由程序员分配释放。
 
 ![9-1](https://github.com/adadcat/MyNode/blob/main/Photo-/9-1.png)
 
 ![9-2](https://github.com/adadcat/MyNode/blob/main/Photo-/9-2.png)
 
 ![9-3](https://github.com/adadcat/MyNode/blob/main/Photo-/9-3.png)
 
10、c++和c的区别
	（1）面向过程和面向对象的区别
	面向过程：分析出解决问题的步骤，然后依次将每一步实现，使用的时候再根据需要调用。
	面向对象：把问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。
	可设计出低耦合的系统，使系统更灵活，更好维护。但类调用需要实例化，开销更大，更消耗资源。
	（2）关键字的不同
	C99有32个关键字；C++98有63个关键字
	struct：在c语言中，struct定义的变量不能有函数，但是在c++中定义的函数可以有函数。
	malloc：函数返回值为void*，在c语言中可以赋值给任意类型的指针，但是在c++中必须经过强制类型转换。
	struct和class：class是对struct的扩展，struct默认的访问权限是public，而class默认的访问权限是private。
	（3）返回值的不同
	C中一个函数没有指定的返回值类型，则默认返回int；c++中，如果一个函数没有返回值，则必须指定void。
	（4）参数列表
	C中，若函数没有指定参数列表，默认可以接收多个参数。C++中，如函数没有指定的参数列表，则视为void，不接收任何参数。
	（5）缺省参数
	声明或定义一个函数时，为函数指定一个默认值。在调用该函数时，若没有指定实参，则采用该默认值。C中没有缺省参数。
	（6）函数重载
	在同一作用域中，声明几个功能类似的同名函数，但是这些函数的形参列表（参数个型、类型、顺序）必须不同，返回值类型可以不同。常用来处理，功能类似但是数据类型不同的问题。C语言没有重载。
	
11、struct和class的区别：
	（1）默认的继承访问权：
	class默认是private；struct默认是public
	（2）默认访问权限：
	class作为对象的实现体，默认的成员访问控制是private；struct作数据结构的实现体，默认的数据访问控制是public。
![11-1](https://github.com/adadcat/MyNode/blob/main/Photo-/11-1.png) 

12.struct内存对齐
	chars可以从任何字节地址开始，2字节short必须从偶数地址开始，4字节的int或float必须从被4整除的地址开始，而8字节的long或double必须从被8整除的地址开始。
	从偏移量为0的地址处开始，尽量按照同类型存储，减少内存的空白。
	结构体总大小为所有成员中最大对齐数的整数倍。
	如果嵌套了结构体，结构体的整体大小是包括嵌套结构体的成员在内的所有最大对齐数的整数倍。
 
![12-1](https://github.com/adadcat/MyNode/blob/main/Photo-/12-1.png) 

![12-2](https://github.com/adadcat/MyNode/blob/main/Photo-/12-2.png) 

13、new delete和malloc free的区别
	（1）new/delete为操作运算符，malloc//free为函数
	（2）new会根据编译器自行计算所需要的内存，而molloc需要显示指出所需要的内存的尺寸。
	int *p = new int[2];
	int *q = (int *)malloc(2*sizeof(int));
	（3）new在分配失败时，会抛出bac_alloc异常
		mollac在分配内存失败时会返回NULL
	（4）mollac内存分配成功时，返回的是void*，需要装换成所需要的类型。
		New内存分配成功时，返回的是与对象类型的指针，类型严格与对象匹配，无需进行类型转换，所以new是符合类型安全性的指针。
		Free释放内存的时候，需要的是void*型指针
		Delete释放内存的时候，需要具体类型的指针
	（5）new操作符从自由存储区（free store）上为对象动态分配内存空间，允许重载new/delete操作符
malloc函数从堆上动态分配内存，malloc不允许被重载

14、内存泄漏
	指的是由于操作失误或错误导致了程序未能释放掉不再使用的内存的情况。值的不是内存的丢失，而是失去了对该内存的控制，造成了内存的浪费。
	
15、sizeof和strlen的对比
	（1）sizeof（）是运算符，strlen（）是库函数
	（2）sizeof（）在编译时就计算好了；strlen（）在运行时计算
	（3）sizeof（）计算出对象所使用的最大字节数；strlen（）计算字符串的大小：从
该字符的第一个地址开始遍历，直到第一个’\0’结束，返回的长度且不包括’\0’
sizeof 计算整个字符串所占内存字节数的大小，当然\0也要+1计算；strlen 计算的是字符串的实际长度，遇到\0即停止
	（4）sizeof（）的参数类型多样化（数组，指针，函数，对象都可以）；strlen（）的参数必须是字符型指针（传入数组时，自动退化为指针）
![15-1](https://github.com/adadcat/MyNode/blob/main/Photo-/15-1.png) 
 
16、指针与引用的区别
	两者都是与地址联系，指针是指向某内存，他的内容就是该内存的地址；引用是某块内存的别名。
	引用定义时需要初始化，并且之后无法改变；指针在任何时候都可以初始化，且指向的对象也可以发生改变。
	没用空引用，但有空指针。
	对引用使用sizeof（），得到的是变量的大小，对指针使用sizeof（），得到的是地址的大小。
	引用只有一级：int && p //非法；int **p//合法；
	
17、野指针
	不等价于空指针，而是指向垃圾内存的指针，指向不可用内存的指针。
	造成野指针的情况：
	指针变量未初始化：任何指针变量在创建时，不会自动成为NULL指针。
		指针指向的内存被释放了，并且没有置NULL
		指针超过了变量的作用范围。
	避免方式：
		绝不返回局部变量和局部数组的地址。
		任何变量在定义后必须0初始化。
		字符数组必须确认0结束符后才能成为字符串。
		任何使用与内存相关的函数必须指定长度信息

18、多态
	函数的不同实现方式即为多态。
	在调用函数时，为了防止不清楚，调用的是基类还是子类的情况出现，就引进了多态。
	多态是指通过基类的指针既可以访问基类的成员，也可以访问派生类的成员。
	构成多态的两个条件：
（1）	调用函数的对象必须是指针或者引用
（2）	被调用的函数必须是虚函数，且完成了对虚函数的重写。

多态分为静态多态和动态多态。
静态多态：也可以称为编译期间的多态；编译器在编译期间完成的，编译器根据函数
实参的实现的类型（可能会进行隐式类型的转换），可推断出要调用那个函数，如果有对应的函数就调用对应的函数，否则就进行编译错误。
	静态多态实现的两种形式：函数重载（包括普通函数的重载和成员函数的重载）；函数模板的使用。
	动态多态：子类重写父类的虚函数（类内实现）；父类指针指向子类对象（类外实现）；用该指针调用虚函数（类外实现）。

19、虚函数实现动态多态的原理
	多态的实现是通过虚函数（Virtual Function）来实现，对于基类和子类来说，有着各自的虚函数表（Virtual Table）。
	在C++的标准规格说明书中说到，编译器必需要保证虚函数表的指针存在于对象实例中最前面的位置（这是 为了保证正确取到虚函数的偏移量）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。

20、虚函数与纯虚函数的区别
	纯虚函数：在基类中仅仅给出声明，不对虚函数实现定义，而是在派生类中实现。普通函数如果仅仅给出声明而没有实现他的函数体，是没有办法编译的，而纯虚函数没有函数体。而纯虚函数需要在声明之后加一个 =0。
	纯虚函数在派生类中重新定义后，派生类才能实例化出对象。
class 基类名
{
	virtual 类型 函数名 (参数表) = 0；
	………
}；
	抽象类：含有纯虚函数的类。抽象类只能作为派生类的基类，不能定义对象，但可以定义指针。


21、继承时，父类的析构函数是否为虚函数？构造函数能不能为虚函数？
	C++类有继承时，析构函数必须为虚函数。
	结果就是只会调用父类的析构函数，而不会调用子类的析构函数，从而可能导致子类的内存泄漏（如果子类析构函数中存在free delete等释放内存操作时。

22、静态多态：重写、重载、模板
	重写：假设基类和派生类都有一个具有相同名称和参数（参数的数量和类型）的成员函数。如果创建派生类的对象，并调用在两个类（基类和派生类）都存在的成员函数，则将调用派生类的成员函数，而忽略基类的成员函数。	
		如果要从派生类调用基类的重写函数，则需要使用范围解析运算符：：	
		基类函数必须有virtual关键字
	重载：在同一个作用域中的某个函数和运算符有多个定义，即可称为函数的重载和运算符的重载。	
		重载决策：当调用一个函数重载或运算符重载时，编译器会将所使用的参数类型与定义中的参数类型进行比较，选出最适合的函数重载和运算符重载。
		函数重载：在同一个作用域中，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（值参数的个数、类型和顺序必须不同）。不能仅通过返回值类型的不同来重载函数。
		运算符的重载：重载的运算符是带有特殊名称的函数，函数名是由关键字operator和其后要重载的运算符构成。与其他函数一样，重载运算符有一个返回类型和参数列表。
  
 ![22-1](https://github.com/adadcat/MyNode/blob/main/Photo-/22-1.png) 
 
 ![22-2](https://github.com/adadcat/MyNode/blob/main/Photo-/22-2.png) 
 
 ![22-3](https://github.com/adadcat/MyNode/blob/main/Photo-/22-3.png) 
 
 ![22-4](https://github.com/adadcat/MyNode/blob/main/Photo-/22-4.png) 
 
 ![22-5](https://github.com/adadcat/MyNode/blob/main/Photo-/22-5.png) 
 
   
	模板：是对类型进行参数化的工具。一般分为函数模板和类模板。
		函数模板：一般以以下形式
template <typename type> ret-type func-name(parameter list)
{
	// type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用
 	// 函数的主体 
}
	类模板：一般以以下形式
template  < class type> class class-name
{
	// type 是占位符类型名称，可以在类被实例化的时候进行指定。	
	//可以使用一个逗号分隔的列表来定义多个泛型数据类型
}
	
23、static关键字：控制变量的存储方式和可见性。
	静态局部变量：具有局部作用域，只能被初始化一次，之后直到到程序结束，生命周期才结束。
	静态全局变量：具有全局作用域，但和全局变量的不同之处在于，只作用于定义它的文件中，不能作用在其他文件里。
 
	修饰类中成员变量：
1、	实现了同类成员的信息共享；
2、	static成员类外存储，求类的大小，并不会包含在内
3、	static成员是命名空间属于类的全局变量，储存在data区
4、	static只能在类外初始化
5、	可以通过类名访问（无对象生成也可以），也可以通过对象访问。
 
 
	修饰类中成员函数：
		用于管理数据成员，完成对静态数据成员的封装。
		静态成员函数只能访问静态数据成员。非静态成员函数，在调用时this指针被当作参数传递。而静态成员函数属于类，不属于对象，没有this指针。
	 
 ![23-1](https://github.com/adadcat/MyNode/blob/main/Photo-/23-1.png) 
 
 ![23-2](https://github.com/adadcat/MyNode/blob/main/Photo-/23-2.png) 
 
 ![23-3](https://github.com/adadcat/MyNode/blob/main/Photo-/23-3.png) 
 
 ![23-4](https://github.com/adadcat/MyNode/blob/main/Photo-/23-4.png) 
 
 ![23-5](https://github.com/adadcat/MyNode/blob/main/Photo-/23-5.png) 

24、const关键字：
 
	修饰变量：修饰全局变量：会限定全局变量的作用范围到其定义时所在的编译单元；被修饰的全局变量不被允许修改。
	修饰指针：指针常量->指针不可以改，指针指向的对象可以改；常量指针->指针可以改，指针指向的对象不可以改。
	修饰引用：常引用所引用的对象不可更新。非const引用只能绑定非const对象，const引用只能绑定const可以绑定任意对象，并且都当作常对象。常引用经常用作形参，防止函数内对象被意外修改。
	修饰成员函数：const对象只能访问const成员函数，而非const对象可以访问任意成员函数。  const成员是不可以修改的，而通过指针维护的对象是可以修改的。  const成员函数不可以修改对象的数据，不管对象是否具有const性质。编译时，以是否修改成员数据进行检查。
 
![24-1](https://github.com/adadcat/MyNode/blob/main/Photo-/24-1.png) 
![24-1](https://github.com/adadcat/MyNode/blob/main/Photo-/24-2.png) 
	
