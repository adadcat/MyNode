一、
创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
其实还有两类：并发型模式和线程池模式。

二、创建型模式
  工厂模式是在意生产出产品A、B、C，而建造者模式在意的是，产品的部件：a、b、c.
  
1、工厂方法：定义一个用于创建对象的接口，由子类决定实例化那一个类。

//抽象产品
class Product
{
public:
  virtual void Production() = 0;
};

class ProductA : public Product
{
public:
  virtual void Production()
  {
    cout<<"production A "<<endl;
  }
};

class ProductB : public Product
{
public:
  virtual void Production()
  {
    cout<<"production B" <<endl;
  }
};

//抽象工厂
class Factory
{
public:
  virutal Product *CreateProduction() = 0;
};

class FactoryA : public Factory
{
public:
  Product *CreateProduction(){return new ProductA()};
};

class FactoryB : public Factory
{
public:
  Product *CreateProduction(){return new ProductB()};
};

int main()
{
  Factory *factory1 = new FactoryA();
  Factory *factory2 = new FactoryB();
  Product *product1 = FactoryA->CreateProduction();
  Product *product2 = FactoryB->CreateProduction();
  product1->Production();
  product2->Production();
}


2.抽象工厂模式：针对多个产品，不同的产品链
class AbstractProductA
{
public:
  virutal ~AbstractProduct();
  virtual void ProductionA() = 0;
};

class AbstractProductA1 : public AbstractProductA
{
public:
  void ProductionA() override {cout<<"AbstractProductA1"<<endl;}
};

class AbstractProductA2 : public AbstractProductA
{
public:
  void ProductionA() override {cout<<"AbstractProductA2"<<endl;}
};

class AbstractProductB
{
public:
  virutal ~AbstractProductB();
  virutal void ProductionB() = 0;
};

class AbstractProductB1 : public AbstractProductB
{
public:
  void ProductionB() override {cout<<"AbstractProductB1"<<endl;}
};

class AbstractProductB2 : public AbstractProductB
{
public:
  void ProductionB() override {cout<<"AbstractProductB2"<<endl;}
};

class AbstractFactory
{
public:
  virtual AbstractProductA *CreateProductA() = 0;
  virutal AbstractProductB *CreateProductB() = 0;
};

class AbstractFactoryA : public AbstractFactory
{
public:
  AbstractProductA *CreateProductA() override {return new AbstractProductA1();}
  AbstractProductB *CreateProductB() override {return new AbstractProductB1();}
};

class AbstractFactoryB : public AbstractFactory
{
public:
  AbstractProductA *CreatProductA() override {return new AbstractProductA2();}
  AbstractProductB *CreatProductB() override {return new AbstractProductB2();}
};


3.建造者模式:将一个复杂对象的构建与它的表示分离，使得同样的创建过程可以创建不同的模式。调整构造的顺序
*Builder：为创建产品各个部分，统一抽象接口
*ConcreteBuilder: 具体的创建产品的各个部分，部分A，部分B，部分C
*Director: 构造一个使用Builder接口的对象
*Product：表示被构造的复杂对象


class Director
{
public:
  Director();
  Director(Builder *builder);
  ~Director();

  void create();
  void create(Builder *builder);
private:
  Builder * m_builder;
};

class Builder
{
public:
  Builder();
  ~Builder();
  virtual void builderA() = 0;
  virtual void builderB() = 0;
  virutal void builderC() = 0;
}

class ProductionABuilder : public Builer
{
public:
  ProductionABuilder();
  void builderA() override() {cout<<"this is ProductionABuilder";}
  void builderB() override() {cout<<"this is ProductionABuilder";}
  void builderC() override() {cout<<"this is ProductionABuilder";}
};

class ProductionBBuilder : public Builer
{
public:
  ProductionABuilder();
  void builderA() override() {cout<<"this is ProductionBBuilder";}
  void builderB() override() {cout<<"this is ProductionBBuilder";}
  void builderC() override() {cout<<"this is ProductionBBuilder";}
};
